// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float2 TextureSize;

[numthreads(8,8,1)]
void CSMain (uint2 id : SV_DispatchThreadID)
{
    // Get the texture size (for normalizing the UV coordinates)
    float2 uv = float2(id.x, id.y) / TextureSize;

    // Output the UV coordinates as RGB (to visualize them)
    Result[id] = float4(uv, 0.0f, 1.0f); // Red = u, Green = v, Blue = 0, Alpha = 1
}




// --- Variables ---

#define THREADS_X 8
#define THREADS_Y 8

uint2 Resolution; // (width, height)

// for AddForce kernel
float2 ForceOrigin; // in [0,1] UV
float2 ForceVector;
float Radius;
float DensityAmount;

// other
float2 InvResolution; // (1/width, 1/height) - computed in c#
float DeltaTime;
float VelocityDissipation; // per-second damping (e.g. 0.02)
float DensityDissipation; // per-second dye dissipation (e.g. 0.02)
int DensityChannel;

// Diffusion Jacobi parameters (alpha, beta)
float DiffuseAlpha;
float DiffuseBeta;

// mouse line making
float2 LineStart;
float2 LineEnd;

// --- textures for advect/diffuse/project ---
Texture2D<float2> VelocityRead;
RWTexture2D<float2> VelocityWrite;

Texture2D<float> DensityRead;
RWTexture2D<float> DensityWrite;

Texture2D<float> PressureRead;
RWTexture2D<float> PressureWrite;

RWTexture2D<float> DivergenceRead;
RWTexture2D<float> DivergenceWrite;


// ---------- mouse write density & velocity ----------

#pragma kernel AddForceLine

[numthreads(8, 8, 1)]
void AddForceLine(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / float2(Resolution);

    // Step count based on line length in texels
    float2 ab = LineEnd - LineStart;
    float lineLen = length(ab * Resolution); // convert UV to pixel space
    int steps = (int) ceil(lineLen); // one sample per pixel length
    steps = max(steps, 1);

    float totalFalloff = 0.0;

    // march along the line
    for (int i = 0; i <= steps; i++)
    {
        float t = (steps == 0) ? 0.0 : (float) i / (float) steps;
        float2 pos = lerp(LineStart, LineEnd, t);

        float dist = distance(uv, pos);
        if (dist < Radius)
        {
            float falloff = 1.0 - saturate(dist / Radius);
            totalFalloff = max(totalFalloff, falloff); // take max contribution
        }
    }

    if (totalFalloff > 0.0)
    {
        float oldDensity = DensityWrite[id.xy];
        oldDensity += DensityAmount * totalFalloff;
        DensityWrite[id.xy] = oldDensity;

        float2 oldVel = VelocityWrite[id.xy];
        VelocityWrite[id.xy] = oldVel + ForceVector * totalFalloff;
    }
}


// ---------- common resources ----------

SamplerState sampler_linear_clamp
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
};

// ---------- helpers ----------
float2 SampleVelocityUV(Texture2D<float2> tex, float2 uv)
{
    return tex.SampleLevel(sampler_linear_clamp, uv, 0);
}
float SampleScalar(Texture2D<float> tex, float2 uv)
{
    return tex.SampleLevel(sampler_linear_clamp, uv, 0);

}

// =======================================================
// ADVECT VELOCITY
// Semi-Lagrangian: backtrace using velocity field (in UV units/sec)
// =======================================================

#pragma kernel AdvectVelocity

[numthreads(THREADS_X, THREADS_Y, 1)]
void AdvectVelocity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / float2(Resolution); // normalized uv
    float2 vel = SampleVelocityUV(VelocityRead, uv);

    // backtrace position in uv-space
    float2 prevUV = uv - vel * DeltaTime;

    // clamp prevUV to domain (sampler already clamps)
    float2 advectedVel = SampleVelocityUV(VelocityRead, prevUV);

    // apply simple damping
    advectedVel *= (1.0 - VelocityDissipation * DeltaTime);

    VelocityWrite[id.xy] = advectedVel;
}


// =======================================================
// ADVECT DENSITY (scalar)
// =======================================================

#pragma kernel AdvectDensity

[numthreads(THREADS_X, THREADS_Y, 1)]
void AdvectDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / float2(Resolution); // normalized uv
    float2 vel = SampleVelocityUV(VelocityRead, uv);

    // backtrace position in uv-space
    float2 prevUV = uv - vel * DeltaTime;
    
    float advected = SampleScalar(DensityRead, prevUV);
    advected *= (1.0 - DensityDissipation * DeltaTime);
    DensityWrite[id.xy] = advected;

}



// =======================================================
// DIFFUSE (Jacobi) - single kernel for scalar or vector depending on bindings
// Configure DiffuseAlpha and DiffuseBeta from C# before dispatch.
// If you want to run only on density or only on velocity, bind/unbind appropriately.
// =======================================================

#pragma kernel DiffuseVelocity

[numthreads(8, 8, 1)]
void DiffuseVelocity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;
    float2 uv = (float2(id.xy) + 0.5) / float2(Resolution);
    float2 px = 1.0 / float2(Resolution);

    float2 vC = VelocityRead.SampleLevel(sampler_linear_clamp, uv, 0);
    float2 vL = VelocityRead.SampleLevel(sampler_linear_clamp, uv + float2(-px.x, 0), 0);
    float2 vR = VelocityRead.SampleLevel(sampler_linear_clamp, uv + float2(px.x, 0), 0);
    float2 vB = VelocityRead.SampleLevel(sampler_linear_clamp, uv + float2(0, -px.y), 0);
    float2 vT = VelocityRead.SampleLevel(sampler_linear_clamp, uv + float2(0, px.y), 0);

    float2 vNew = (vL + vR + vB + vT + DiffuseAlpha * vC) / DiffuseBeta;
    VelocityWrite[id.xy] = vNew;
}

#pragma kernel DiffuseDensity

[numthreads(8, 8, 1)]
void DiffuseDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;
    float2 uv = (float2(id.xy) + 0.5) / float2(Resolution);
    float2 px = 1.0 / float2(Resolution);

    float dC = DensityRead.SampleLevel(sampler_linear_clamp, uv, 0);
    float dL = DensityRead.SampleLevel(sampler_linear_clamp, uv + float2(-px.x, 0), 0);
    float dR = DensityRead.SampleLevel(sampler_linear_clamp, uv + float2(px.x, 0), 0);
    float dB = DensityRead.SampleLevel(sampler_linear_clamp, uv + float2(0, -px.y), 0);
    float dT = DensityRead.SampleLevel(sampler_linear_clamp, uv + float2(0, px.y), 0);

    float dNew = (dL + dR + dB + dT + DiffuseAlpha * dC) / DiffuseBeta;
    DensityWrite[id.xy] = dNew;
}




// =======================================================
// COMPUTE DIVERGENCE
// div = (<inv6>u/<inv6>x + <inv6>v/<inv6>y) using central differences
// divergence = ((vR.x - vL.x) / (2h)) + ((vT.y - vB.y) / (2h))
// We'll store divergence in DivergenceTex
// =======================================================

#pragma kernel ComputeDivergence

[numthreads(THREADS_X, THREADS_Y, 1)]
void ComputeDivergence(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / float2(Resolution);
    float2 px = 1.0 / float2(Resolution);

    float2 vL = SampleVelocityUV(VelocityRead, uv + float2(-px.x, 0));
    float2 vR = SampleVelocityUV(VelocityRead, uv + float2(px.x, 0));
    float2 vB = SampleVelocityUV(VelocityRead, uv + float2(0, -px.y));
    float2 vT = SampleVelocityUV(VelocityRead, uv + float2(0, px.y));

    float div = 0.5 * ((vR.x - vL.x) / px.x + (vT.y - vB.y) / px.y);
    DivergenceWrite[id.xy] = div;
}


// =======================================================
// PRESSURE JACOBI: Solve <delta^2> p = divergence
// p_new = (pL + pR + pB + pT - divergence * h * h) * 0.25
// Make sure C# binds PressureRead, PressureWrite and DivergenceTex
// =======================================================

#pragma kernel PressureJacobi

[numthreads(THREADS_X, THREADS_Y, 1)]
void PressureJacobi(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / float2(Resolution);
    float2 px = 1.0 / float2(Resolution);
    float h = 1.0 / Resolution.x; // if non-square, using x; consistent scaling assumed

    float pL = PressureRead.SampleLevel(sampler_linear_clamp, uv + float2(-px.x, 0), 0).r;
    float pR = PressureRead.SampleLevel(sampler_linear_clamp, uv + float2(px.x, 0), 0).r;
    float pB = PressureRead.SampleLevel(sampler_linear_clamp, uv + float2(0, -px.y), 0).r;
    float pT = PressureRead.SampleLevel(sampler_linear_clamp, uv + float2(0, px.y), 0).r;

    float div = DivergenceRead[id.xy];

    float pNew = (pL + pR + pB + pT - div * (h * h)) * 0.25;
    PressureWrite[id.xy] = pNew;
}


// =======================================================
// SUBTRACT GRADIENT: v = v - <delta>p  (projection)
// gradient approximated with central differences
// =======================================================

#pragma kernel SubtractGradient

[numthreads(THREADS_X, THREADS_Y, 1)]
void SubtractGradient(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;

    float2 uv = (float2(id.xy) + 0.5) / float2(Resolution);
    float2 px = 1.0 / float2(Resolution);

    float pL = PressureRead.SampleLevel(sampler_linear_clamp, uv + float2(-px.x, 0), 0).r;
    float pR = PressureRead.SampleLevel(sampler_linear_clamp, uv + float2(px.x, 0), 0).r;
    float pB = PressureRead.SampleLevel(sampler_linear_clamp, uv + float2(0, -px.y), 0).r;
    float pT = PressureRead.SampleLevel(sampler_linear_clamp, uv + float2(0, px.y), 0).r;

    float2 grad = float2((pR - pL) * 0.5 / px.x, (pT - pB) * 0.5 / px.y);

    float2 vel = SampleVelocityUV(VelocityRead, uv);
    vel -= grad;

    VelocityWrite[id.xy] = vel;
}



#pragma kernel ColorizeDensity

RWTexture2D<float4> DyeWrite;

Texture2D<float4> DensityGradient;
float4 BackgroundColor;

[numthreads(8, 8, 1)]
void ColorizeDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;

    float densityVal = DensityRead[id.xy]; // scalar
    float4 dyeCol = DensityGradient.SampleLevel(sampler_linear_clamp, float2(saturate(densityVal), 0), 0);

    // Mix with background
    float4 finalColor = lerp(BackgroundColor, dyeCol, saturate(densityVal));

    DyeWrite[id.xy] = finalColor;
}


// for DEBUG

#pragma kernel VisualizeVelocity

RWTexture2D<float4> VelocityDebug;


float3 hsv2rgb(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}

[numthreads(8, 8, 1)]
void VisualizeVelocity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Resolution.x || id.y >= Resolution.y)
        return;

    float2 vel = VelocityRead[id.xy];
    float mag = length(vel);

    // angle to hue, magnitude to brightness
    float angle = atan2(vel.y, vel.x);
    float hue = (angle / 6.28318530718) + 0.5; // 0..1
    float sat = 1.0;
    float val = saturate(mag * 0.1); // scale down

    float3 rgb = hsv2rgb(float3(hue, sat, val));
    VelocityDebug[id.xy] = float4(rgb, 1.0);
}
